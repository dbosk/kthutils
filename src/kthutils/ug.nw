\chapter{The UG editor}

This is the documentation for the [[kthutils.ug]] module.
We want to create an interface to KTH's UG groups editor.
We particularly want to be able to automate adding TAs to the UG groups for 
courses.

We provide two interfaces:
First, a class, [[UGsession]], through which we interact with the UG system 
through Python.
Second, a CLI, [[cli]], using Typer.
<<ug.py>>=
import cachetools as ct
import functools as ft
import json
import logging
import operator
import re
import requests
import weblogin
import weblogin.kth

<<additional imports>>

<<helper functions>>

class UGsession:
  """
  Maintains a session to the UG Editor APIs.
  """
  BASE_URL = "https://app.kth.se/ug-gruppeditor"

  def __init__(self, username, password):
    """
    Requires `username` and `password` which are the normal credentials for 
    logging in through https://login.ug.kth.se.

    All API requests are performed as this user.
    """
    <<UG constructor>>

  <<UG methods>>

<<set up typer cli>>

if __name__ == "__main__":
  <<run typer cli>>
@


\section{Tests}

We provide tests for the class.
We create a [[ug]] object and will add test functions to [[<<test functions>>]] 
as we add methods to [[<<UG methods>>]].
<<test ug.py>>=
import kthutils.ug
import os

ug = kthutils.ug.UGsession(os.environ["KTH_LOGIN"], os.environ["KTH_PASSWD"])

<<test functions>>
@


\section{The CLI}

We will use Typer to construct the CLI.
We also want to use the pretty-printing of the [[rich]] package.
<<additional imports>>=
from rich import print
import typer
<<set up typer cli>>=
cli = typer.Typer(name="ug", help="Interacts with the KTH UG Editor")

<<add commands to cli>>
<<run typer cli>>=
cli()
@

Typer requires that we use static functions or class methods as commands.
We can't use the methods of an object instance as CLI commands.
Hence, to create the CLI, we can create a function for each command.
This means that we must create an instance of [[UGsession]] and perform the 
method calls on that in normal functions, one function (command) per method.
Each command matches a method call on the [[ug]] object.

However, to create that we need the user's credentials.
We'll use the [[credentials]] module and its [[get_credentials]] function for 
this.
We simply unpack the (username, password) tuple we get and pass it directly to 
[[UGsession]].
<<additional imports>>=
import kthutils.credentials
<<create UGsession instance ug or exit>>=
ug = UGsession(*kthutils.credentials.get_credentials())
@


\section{Constructing a UG session}

All we need for the UG session object is a [[requests]] session to the UG web 
interface.
However, it requires logging in to use it, so we use
[[weblogin.AutologinSession]]
together with the KTH UG login handler
[[weblogin.kth.UGlogin]]
for that.
<<UG constructor>>=
self.__session = weblogin.AutologinSession([
      weblogin.kth.UGlogin(username, password,
                          self.BASE_URL)
  ])
@


\section{Listing editable groups}

The first thing we want to do is to be able to list all groups.
<<list doc>>=
Lists all groups that are editable by the logged in user.
Returns list of JSON objects.
@

This will be reused a lot in the other methods, so we want to cache it.
It makes sense to cache it as well, since the data can't change.
(Well, we can't change it, and it doesn't change that often.)
<<UG constructor>>=
self.cache = {}
<<UG methods>>=
@ct.cachedmethod(operator.attrgetter("cache"),
  key=ft.partial(ct.keys.hashkey, "list_editable_groups"))
def list_editable_groups(self):
  """
  <<list doc>>
  """
  response = self.__session.get(
      f"{self.BASE_URL}/api/ug/groups?editableBySelf=true")
  return response.json()
@

We can test the function as follows.
<<test functions>>=
def test_list_editable_groups():
  groups = ug.list_editable_groups()
  assert groups
@

Each JSON object has the following format.
\begin{pycode}
import json
import kthutils.ug

ug = kthutils.ug.UGsession(os.environ["KTH_LOGIN"], os.environ["KTH_PASSWD"])
groups = ug.find_group_by_name("edu.courses.DD.DD1317.20222.1.courseresponsible")

print(r"\begin{minted}{json}")
print(json.dumps(list(groups)[0], indent=2))
print(r"\end{minted}")
\end{pycode}

Now, let's add the CLI command function.
We want to print the name and, if it exists, the description for the group; we 
don't want to print everything that we actually get from the function.
<<add commands to cli>>=
@cli.command()
def ls():
  """
  <<list doc>>
  """
  <<create UGsession instance ug or exit>>
  for group in ug.list_editable_groups():
    name, desc = get_name_desc(group)
    print(f"{name}\t{desc}")
<<helper functions>>=
def get_name_desc(group):
  """
  Returns a tuple (name, desc) containing the name and description, if it 
  exists, for the group `group`. If the group doesn't have a description, the 
  second value is None.
  """
  name = group["name"]

  try:
    desc = group["description"]["en"]
  except KeyError:
    desc = None

  return name, desc
@


\section{Find group by name}

Most of the time we want to find a group by name.
<<find group doc>>=
Searches for a group from `list_editable_groups()` whose name matches the regex 
`name_regex`.
Returns a list of matching groups.
@
<<UG methods>>=
def find_group_by_name(self, name_regex):
  """
  <<find group doc>>
  """
  return filter(lambda group: re.search(name_regex, group["name"]),
                self.list_editable_groups())
@

Now, let's add the CLI command function.
We want the argument [[name_regex]] as argument, but we'd also like to have tab 
completion for it.
We use the function [[complete_group_regex]] for the tab completion.
<<add commands to cli>>=
def complete_group_regex(incomplete: str) -> [str]:
  <<create UGsession instance ug or exit>>
  <<return list of filtered group names>>

@cli.command()
def group(name_regex: str = typer.Argument(..., help="Regex for group name",
                                           autocompletion=complete_group_regex)):
  """
  <<find group doc>>
  """
  <<create UGsession instance ug or exit>>
  print(list(ug.find_group_by_name(name_regex)))
@

For the autocompletion, we want to return a list of only the names, not the 
full JSON for them, as the function returns.
We would also like to return a help text for each name, namely the human 
readable name that is available from the JSON.
This means that we want to return a list of tuples: the name (which the regex 
match) and the description (human readable).
<<return list of filtered group names>>=
names = []

for group in ug.find_group_by_name(incomplete):
  names.append(get_name_desc(group))

return names
@


\section{List members of a group}

The purpose of the groups is the members.
We want to be able to list them.
<<members doc>>=
Returns a list of the members of a group.
The list contains JSON objects.
<<UG methods>>=
def list_group_members(self, group_kthid):
  """
  <<members doc>>
  """
  response = self.__session.get(
    f"{self.BASE_URL}/api/ug/users?$filter=memberOf eq '{group_kthid}'")
  return response.json()
@

Each JSON object in the resulting list has the following format.
\begin{pycode}
import json
import kthutils.ug

ug = kthutils.ug.UGsession(os.environ["KTH_LOGIN"], os.environ["KTH_PASSWD"])
group = list(
    ug.find_group_by_name("edu.courses.DD.DD1317.20222.1.courseresponsible")
  )[0]
members = ug.list_group_members(group["kthid"])

print(r"\begin{minted}{json}")
print(json.dumps(list(members), indent=2))
print(r"\end{minted}")
\end{pycode}

Now, let's add the CLI command function.
We want the argument [[group_kthid]] as argument with tab completion for it.
We use the function [[complete_group_id]] for the tab completion.
<<add commands to cli>>=
def complete_group_id(incomplete: str) -> [str]:
  <<create UGsession instance ug or exit>>
  <<return list of filtered group IDs>>

@cli.command()
def members(group_kthid: str = typer.Argument(..., help="Group's kthid",
                                              autocompletion=complete_group_id)):
  """
  <<members doc>>
  """
  <<create UGsession instance ug or exit>>
  print(list(ug.list_group_members(group_kthid)))
@

For the autocompletion, we want to return a list the kthid's and the names as 
help.
<<return list of filtered group IDs>>=
kthids = []

for group in ug.list_editable_groups():
  if group["kthid"].startswith(incomplete):
    kthids.append((group["kthid"], group["name"]))

return kthids
@


\section{Set members of a group}

The API doesn't allow us to add or remove individual users.
It only allows us to set a new members list.
<<UG methods>>=
def set_group_members(self, members, group_kthid):
  """
  Sets the group members of group identified by `group_kthid` to be the list of 
  users (strings of kthid for users) `members`.

  Returns the updated group data, JSON format.
  """
  headers = self.__session.headers
  headers["content-type"] = "application/merge-patch+json"
  data = {
    "kthid": group_kthid,
    "members": members if isinstance(members, list) \
                       else list(members)
  }

  response = self.__session.patch(
    f"{self.BASE_URL}/api/ug/groups/{group_kthid}",
    data=json.dumps(data), headers=headers)

  if response.status_code != requests.codes.ok:
    raise Exception(f"failed to set members: {response.status_code}: "
                    f"{response.text}")

  return response.json()
@

\subsection{Adding users}

It will probably be more useful to provide a method for adding a user or set of 
users.
<<UG methods>>=
def add_group_members(self, new_members, group_kthid):
  """
  Adds list of members in `new_members` (kthids of users) to group with kthid 
  `group_kthid`.

  Returns the updated group data, JSON format.
  """
  current_members = [x["kthid"] for x in self.list_group_members(group_kthid)]
  return self.set_group_members(
            set(current_members + new_members),
            group_kthid)
@

\subsection{Removing users}

In a similar fashion, we want to remove users too.
<<UG methods>>=
def remove_group_members(self, members, group_kthid):
  """
  Removes the users in `members` (list of kthids) from the group identified by 
  kthid `group_kthid`.

  Returns the updated group data, JSON format.
  """
  current_members = [x["kthid"] for x in self.list_group_members(group_kthid)]
  return self.set_group_members(
            set(current_members) - set(members),
            group_kthid)
@

\subsection{Tests}

We can test this by adding and removing a user from a group.
<<test functions>>=
def test_add_group_members():
  group = ug.add_group_members(["u13aecix"], "u2i9xt3r")
  assert "u13aecix" in group["members"]

def test_remove_group_members():
  group = ug.remove_group_members(["u13aecix"], "u2i9xt3r")
  assert "u13aecix" not in group["members"]
@


\section{Find person by username}

Now we would like to find users based on their username.
<<UG methods>>=
def find_user_by_username(self, username):
  """
  Finds a user by username.
  Returns a list of matching user objects.
  """
  response = self.__session.get(f"{self.BASE_URL}/api/ug/users"
    f"?$filter=username eq '{username}' or emailAliases eq '{username}'")
  return response.json()
@

We test this method as follows.
<<test functions>>=
def test_find_user_by_username():
  data = ug.find_user_by_username("dbosk")
  assert data[0]["username"] == "dbosk"
@

